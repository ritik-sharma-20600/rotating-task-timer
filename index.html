<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1f2937">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Focus Task Timer</title>
  <link rel="manifest" href="manifest.json">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      background: #111827;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      overflow-x: hidden;
      color: #fff;
    }
    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    /* Tailwind-like utility classes */
    .min-h-screen { min-height: 100vh; }
    .bg-gray-900 { background-color: #111827; }
    .bg-gray-800 { background-color: #1f2937; }
    .bg-gray-700 { background-color: #374151; }
    .bg-gray-600 { background-color: #4b5563; }
    .bg-indigo-900 { background-color: #312e81; }
    .bg-indigo-600 { background-color: #4f46e5; }
    .bg-indigo-500 { background-color: #6366f1; }
    .bg-green-600 { background-color: #16a34a; }
    .bg-red-600 { background-color: #dc2626; }
    .bg-yellow-600 { background-color: #ca8a04; }
    .text-white { color: #ffffff; }
    .text-gray-400 { color: #9ca3af; }
    .text-gray-500 { color: #6b7280; }
    .text-indigo-300 { color: #a5b4fc; }
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .items-center { align-items: center; }
    .justify-center { justify-content: center; }
    .gap-1 { gap: 0.25rem; }
    .gap-2 { gap: 0.5rem; }
    .gap-3 { gap: 0.75rem; }
    .p-1\.5 { padding: 0.375rem; }
    .p-2 { padding: 0.5rem; }
    .p-4 { padding: 1rem; }
    .p-8 { padding: 2rem; }
    .p-12 { padding: 3rem; }
    .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
    .px-4 { padding-left: 1rem; padding-right: 1rem; }
    .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
    .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
    .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
    .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
    .py-4 { padding-top: 1rem; padding-bottom: 1rem; }
    .mb-1 { margin-bottom: 0.25rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mb-6 { margin-bottom: 1.5rem; }
    .mb-8 { margin-bottom: 2rem; }
    .mt-2 { margin-top: 0.5rem; }
    .rounded-lg { border-radius: 0.5rem; }
    .rounded-2xl { border-radius: 1rem; }
    .rounded-3xl { border-radius: 1.5rem; }
    .rounded-full { border-radius: 9999px; }
    .w-2 { width: 0.5rem; }
    .w-4 { width: 1rem; }
    .w-5 { width: 1.25rem; }
    .w-6 { width: 1.5rem; }
    .w-8 { width: 2rem; }
    .w-12 { width: 3rem; }
    .w-24 { width: 6rem; }
    .w-full { width: 100%; }
    .h-1\.5 { height: 0.375rem; }
    .h-2 { height: 0.5rem; }
    .h-4 { height: 1rem; }
    .h-5 { height: 1.25rem; }
    .h-6 { height: 1.5rem; }
    .h-12 { height: 3rem; }
    .h-24 { height: 6rem; }
    .h-full { height: 100%; }
    .max-w-md { max-width: 28rem; }
    .mx-auto { margin-left: auto; margin-right: auto; }
    .flex-1 { flex: 1; }
    .text-sm { font-size: 0.875rem; }
    .text-lg { font-size: 1.125rem; }
    .text-2xl { font-size: 1.5rem; }
    .text-3xl { font-size: 1.875rem; }
    .text-4xl { font-size: 2.25rem; }
    .font-medium { font-weight: 500; }
    .font-semibold { font-weight: 600; }
    .font-bold { font-weight: 700; }
    .text-center { text-align: center; }
    .inline-block { display: inline-block; }
    .cursor-pointer { cursor: pointer; }
    .cursor-move { cursor: move; }
    .transition-all { transition: all 0.3s; }
    .transition-colors { transition: color 0.15s, background-color 0.15s; }
    .overflow-hidden { overflow: hidden; }
    .space-y-3 > * + * { margin-top: 0.75rem; }
    .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5); }
    button { border: none; cursor: pointer; outline: none; }
    button:hover { opacity: 0.9; }
    input { outline: none; border: 1px solid #4b5563; }
    input:focus { border-color: #6366f1; }
    input::placeholder { color: #6b7280; }
    .bg-gradient-to-r { background: linear-gradient(to right, #6366f1, #a855f7); }
    .border { border: 1px solid; }
    .border-gray-600 { border-color: #4b5563; }
  </style>
</head>
<body>
  <div id="app"></div>

  <script>
    'use strict';

    // Storage utilities with error handling
    const storage = {
      save: function(key, data) {
        try {
          localStorage.setItem(key, JSON.stringify(data));
          return true;
        } catch (e) {
          console.error('Storage save failed:', e);
          if (e.name === 'QuotaExceededError') {
            alert('Storage quota exceeded. Please clear some data.');
          }
          return false;
        }
      },
      load: function(key, defaultValue) {
        try {
          const item = localStorage.getItem(key);
          if (!item) return defaultValue;
          const parsed = JSON.parse(item);
          return parsed;
        } catch (e) {
          console.error('Storage load failed:', e);
          return defaultValue;
        }
      },
      remove: function(key) {
        try {
          localStorage.removeItem(key);
        } catch (e) {
          console.error('Storage remove failed:', e);
        }
      }
    };

    // Audio context singleton to prevent memory leaks
    let audioContext = null;
    let wakeLock = null;
    
    function getAudioContext() {
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.error('AudioContext not supported:', e);
        }
      }
      return audioContext;
    }

    async function requestWakeLock() {
      if ('wakeLock' in navigator) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('Wake lock acquired');
          
          wakeLock.addEventListener('release', function() {
            console.log('Wake lock released');
          });
        } catch (err) {
          console.error('Wake lock error:', err);
        }
      }
    }

    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release().then(function() {
          wakeLock = null;
        }).catch(function(err) {
          console.error('Wake lock release error:', err);
        });
      }
    }

    // App state
    let state = {
      tasks: [],
      currentTaskIndex: 0,
      isTimerRunning: false,
      showManageTasks: false,
      timerInterval: null,
      timerStartTime: null,
      activeTaskId: null,
      isRendering: false
    };

    // Initialize state from storage
    function initializeState() {
      const defaultTasks = [
        { id: 1, name: 'Coding', allocated: 90, completed: 0 },
        { id: 2, name: 'Exercise', allocated: 30, completed: 0 },
        { id: 3, name: 'Reading', allocated: 45, completed: 0 }
      ];
      
      state.tasks = storage.load('focusTasks', defaultTasks);
      state.timerStartTime = storage.load('timerStartTime', null);
      state.activeTaskId = storage.load('activeTaskId', null);
      
      // Validate loaded tasks
      if (!Array.isArray(state.tasks) || state.tasks.length === 0) {
        state.tasks = defaultTasks;
        saveTasks();
      }
      
      // Ensure all tasks have required fields
      state.tasks = state.tasks.map(task => ({
        id: task.id || Date.now(),
        name: task.name || 'Unnamed Task',
        allocated: typeof task.allocated === 'number' && task.allocated > 0 ? task.allocated : 30,
        completed: typeof task.completed === 'number' && task.completed >= 0 ? task.completed : 0
      }));
    }

    function saveTasks() {
      storage.save('focusTasks', state.tasks);
    }

    function saveTimerState() {
      storage.save('timerStartTime', state.timerStartTime);
      storage.save('activeTaskId', state.activeTaskId);
    }

    function getIncompleteTasks() {
      return state.tasks.filter(t => t && t.completed < t.allocated);
    }

    function formatTime(minutes) {
      if (typeof minutes !== 'number' || isNaN(minutes)) {
        return '0m';
      }
      const hrs = Math.floor(minutes / 60);
      const mins = Math.floor(minutes % 60);
      if (hrs > 0) {
        return hrs + 'h ' + mins + 'm';
      }
      return mins + 'm';
    }

    function startTimer() {
      if (state.timerInterval) return;
      
      const incompleteTasks = getIncompleteTasks();
      if (incompleteTasks.length === 0) return;
      
      const currentTask = incompleteTasks[state.currentTaskIndex];
      if (!currentTask) return;
      
      // Request wake lock to keep screen active
      requestWakeLock();
      
      state.timerStartTime = Date.now();
      state.activeTaskId = currentTask.id;
      saveTimerState();
      
      state.timerInterval = setInterval(function() {
        if (!state.timerStartTime || !state.activeTaskId) {
          stopTimer();
          return;
        }
        
        const now = Date.now();
        const elapsedMinutes = (now - state.timerStartTime) / 60000;
        
        const taskIndex = state.tasks.findIndex(t => t && t.id === state.activeTaskId);
        if (taskIndex !== -1 && state.tasks[taskIndex]) {
          state.tasks[taskIndex].completed = Math.min(
            state.tasks[taskIndex].completed + elapsedMinutes,
            state.tasks[taskIndex].allocated
          );
          state.timerStartTime = now;
          saveTasks();
          saveTimerState();
          render();
          
          if (state.tasks[taskIndex].completed >= state.tasks[taskIndex].allocated) {
            stopTimer();
            state.isTimerRunning = false;
            releaseWakeLock();
            playCompletionSound();
            render();
          }
        } else {
          stopTimer();
        }
      }, 1000);
    }

    function stopTimer() {
      if (state.timerInterval) {
        clearInterval(state.timerInterval);
        state.timerInterval = null;
      }
      state.timerStartTime = null;
      state.activeTaskId = null;
      releaseWakeLock();
      saveTimerState();
    }

    function toggleTimer() {
      state.isTimerRunning = !state.isTimerRunning;
      if (state.isTimerRunning) {
        startTimer();
      } else {
        stopTimer();
      }
      render();
    }

    function nextTask() {
      stopTimer();
      state.isTimerRunning = false;
      const incompleteTasks = getIncompleteTasks();
      if (incompleteTasks.length > 0) {
        state.currentTaskIndex = (state.currentTaskIndex + 1) % incompleteTasks.length;
      }
      render();
    }

    function selectTask(index) {
      stopTimer();
      state.isTimerRunning = false;
      const incompleteTasks = getIncompleteTasks();
      if (index >= 0 && index < incompleteTasks.length) {
        state.currentTaskIndex = index;
      }
      render();
    }

    function resetAllTasks() {
      stopTimer();
      state.tasks = state.tasks.map(t => t ? { ...t, completed: 0 } : t).filter(Boolean);
      state.currentTaskIndex = 0;
      state.isTimerRunning = false;
      saveTasks();
      render();
    }

    function validateMinutes(value) {
      const num = parseFloat(value);
      if (isNaN(num) || num <= 0) {
        return null;
      }
      return Math.max(0.5, Math.round(num * 2) / 2); // Round to nearest 0.5
    }

    function addTask(name, allocated) {
      const validatedTime = validateMinutes(allocated);
      if (!name || !name.trim()) {
        alert('Task name cannot be empty');
        return false;
      }
      if (validatedTime === null) {
        alert('Please enter a valid time (greater than 0)');
        return false;
      }
      const newTask = {
        id: Date.now() + Math.random(),
        name: name.trim(),
        allocated: validatedTime,
        completed: 0
      };
      state.tasks.push(newTask);
      saveTasks();
      render();
      return true;
    }

    function deleteTask(id) {
      const task = state.tasks.find(t => t && t.id === id);
      if (!task) return;
      
      if (confirm('Delete "' + task.name + '"?')) {
        state.tasks = state.tasks.filter(t => t && t.id !== id);
        
        if (state.activeTaskId === id) {
          stopTimer();
          state.isTimerRunning = false;
        }
        
        const incompleteTasks = getIncompleteTasks();
        if (state.currentTaskIndex >= incompleteTasks.length) {
          state.currentTaskIndex = Math.max(0, incompleteTasks.length - 1);
        }
        
        saveTasks();
        render();
      }
    }

    function updateTask(id, name, allocated) {
      const validatedTime = validateMinutes(allocated);
      if (!name || !name.trim()) {
        alert('Task name cannot be empty');
        return;
      }
      if (validatedTime === null) {
        alert('Please enter a valid time (greater than 0)');
        return;
      }
      const taskIndex = state.tasks.findIndex(t => t && t.id === id);
      if (taskIndex !== -1 && state.tasks[taskIndex]) {
        state.tasks[taskIndex].name = name.trim();
        state.tasks[taskIndex].allocated = validatedTime;
        // Adjust completed if it exceeds new allocated
        state.tasks[taskIndex].completed = Math.min(
          state.tasks[taskIndex].completed,
          validatedTime
        );
        saveTasks();
        render();
      }
    }

    function completeTask(id) {
      const taskIndex = state.tasks.findIndex(t => t && t.id === id);
      if (taskIndex !== -1 && state.tasks[taskIndex]) {
        state.tasks[taskIndex].completed = state.tasks[taskIndex].allocated;
        saveTasks();
        
        const incompleteTasks = getIncompleteTasks();
        if (incompleteTasks.length === 0) {
          playCompletionSound();
          state.showManageTasks = false;
        }
        render();
      }
    }

    function resetTask(id) {
      const taskIndex = state.tasks.findIndex(t => t && t.id === id);
      if (taskIndex !== -1 && state.tasks[taskIndex]) {
        state.tasks[taskIndex].completed = 0;
        saveTasks();
        render();
      }
    }

    function moveTask(fromIndex, toIndex) {
      if (fromIndex < 0 || fromIndex >= state.tasks.length || 
          toIndex < 0 || toIndex >= state.tasks.length ||
          fromIndex === toIndex) {
        return;
      }
      const task = state.tasks.splice(fromIndex, 1)[0];
      state.tasks.splice(toIndex, 0, task);
      saveTasks();
      render();
    }

    function playCompletionSound() {
      try {
        // Vibrate phone
        if ('vibrate' in navigator) {
          navigator.vibrate([200, 100, 200, 100, 200, 100, 200]);
        }
        
        // Play sound at maximum volume
        const ctx = getAudioContext();
        if (ctx) {
          // Resume context if suspended (iOS requirement)
          if (ctx.state === 'suspended') {
            ctx.resume();
          }
          
          function playBeep(startTime, frequency, duration) {
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            
            // Maximum volume
            gainNode.gain.setValueAtTime(1.0, startTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
            
            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
          }
          
          const now = ctx.currentTime;
          // Longer, louder beeps
          playBeep(now, 600, 0.4);
          playBeep(now + 0.45, 800, 0.4);
          playBeep(now + 0.9, 1000, 0.4);
          playBeep(now + 1.35, 1200, 0.5);
        }
        
        // Create persistent notification with sound
        if ('Notification' in window && Notification.permission === 'granted') {
          const notificationOptions = {
            body: 'Great job! Time to move on to the next task.',
            icon: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Crect fill="%234f46e5" width="100" height="100"/%3E%3Ctext x="50" y="70" font-size="60" text-anchor="middle" fill="white"%3Eâœ“%3C/text%3E%3C/svg%3E',
            tag: 'task-complete',
            requireInteraction: true, // Keeps notification visible
            silent: false, // Use system notification sound
            vibrate: [200, 100, 200, 100, 200, 100, 200],
            actions: [
              {
                action: 'view',
                title: 'View Tasks'
              }
            ]
          };
          
          const notification = new Notification('Task Complete! ðŸŽ‰', notificationOptions);
          
          notification.onclick = function() {
            window.focus();
            notification.close();
          };
          
          // Don't auto-close so it persists on lock screen
          setTimeout(function() {
            if (document.hidden) {
              // Keep it open if phone is locked
              return;
            }
            notification.close();
          }, 10000);
        }
        
        // Setup Media Session for lock screen
        if ('mediaSession' in navigator) {
          navigator.mediaSession.metadata = new MediaMetadata({
            title: 'Task Complete!',
            artist: 'Focus Timer',
            album: 'Productivity',
            artwork: [
              {
                src: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"%3E%3Crect fill="%234f46e5" width="512" height="512"/%3E%3Ctext x="256" y="380" font-size="300" text-anchor="middle" fill="white"%3Eâœ“%3C/text%3E%3C/svg%3E',
                sizes: '512x512',
                type: 'image/svg+xml'
              }
            ]
          });
        }
        
      } catch (e) {
        console.error('Notification error:', e);
      }
    }

    function requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission().catch(function(err) {
          console.log('Notification permission denied:', err);
        });
      }
    }

    function exportTasks() {
      try {
        if (state.tasks.length === 0) {
          alert('No tasks to export');
          return;
        }
        
        const dataStr = JSON.stringify(state.tasks, null, 2);
        const dataBlob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        const dateStr = new Date().toISOString().split('T')[0];
        link.download = 'focus-tasks-backup-' + dateStr + '.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(function() {
          URL.revokeObjectURL(url);
        }, 100);
      } catch (err) {
        alert('Error exporting tasks: ' + err.message);
      }
    }

    function importTasks() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(event) {
          try {
            const imported = JSON.parse(event.target.result);
            
            if (!Array.isArray(imported)) {
              alert('Invalid file format: expected an array of tasks');
              return;
            }
            
            if (imported.length === 0) {
              alert('File contains no tasks');
              return;
            }
            
            const isValid = imported.every(function(task) {
              return task && 
                     task.id && 
                     task.name && 
                     typeof task.allocated === 'number' && 
                     typeof task.completed === 'number';
            });
            
            if (!isValid) {
              alert('Invalid task data format');
              return;
            }
            
            const msg = 'This will replace all ' + state.tasks.length + 
                       ' current tasks with ' + imported.length + ' imported tasks. Continue?';
            if (confirm(msg)) {
              stopTimer();
              state.isTimerRunning = false;
              state.currentTaskIndex = 0;
              state.tasks = imported;
              saveTasks();
              render();
              alert('Tasks imported successfully!');
            }
          } catch (err) {
            alert('Error reading file: ' + err.message);
          }
        };
        reader.onerror = function() {
          alert('Error reading file');
        };
        reader.readAsText(file);
      };
      input.click();
    }

    function checkTimerOnLoad() {
      if (state.timerStartTime && state.activeTaskId) {
        const now = Date.now();
        const elapsedMinutes = (now - state.timerStartTime) / 60000;
        
        const taskIndex = state.tasks.findIndex(t => t && t.id === state.activeTaskId);
        if (taskIndex !== -1 && state.tasks[taskIndex]) {
          state.tasks[taskIndex].completed = Math.min(
            state.tasks[taskIndex].completed + elapsedMinutes,
            state.tasks[taskIndex].allocated
          );
          saveTasks();
          
          if (state.tasks[taskIndex].completed >= state.tasks[taskIndex].allocated) {
            state.timerStartTime = null;
            state.activeTaskId = null;
            state.isTimerRunning = false;
            saveTimerState();
            playCompletionSound();
          } else {
            state.isTimerRunning = true;
            state.timerStartTime = now;
            saveTimerState();
          }
        } else {
          state.timerStartTime = null;
          state.activeTaskId = null;
          state.isTimerRunning = false;
          saveTimerState();
        }
      }
    }

    // Render functions
    function renderTimerView() {
      const incompleteTasks = getIncompleteTasks();
      
      if (incompleteTasks.length === 0) {
        return '<div class="min-h-screen bg-gray-900 flex items-center justify-center p-4">' +
          '<div class="bg-gray-800 rounded-3xl shadow-2xl p-12 max-w-md w-full text-center">' +
            '<div class="w-24 h-24 bg-green-600 rounded-full flex items-center justify-center mx-auto mb-6">' +
              '<svg class="w-12 h-12 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                '<polyline points="20 6 9 17 4 12"></polyline>' +
              '</svg>' +
            '</div>' +
            '<h2 class="text-3xl font-bold text-white mb-4">All Tasks Complete!</h2>' +
            '<p class="text-gray-400 mb-8">You\'ve finished all your tasks. Great work!</p>' +
            '<button onclick="resetAllTasks()" class="bg-green-600 text-white px-6 py-3 rounded-full font-semibold transition-colors w-full">' +
              'Start New Cycle' +
            '</button>' +
          '</div>' +
        '</div>';
      }

      if (state.currentTaskIndex >= incompleteTasks.length) {
        state.currentTaskIndex = 0;
      }

      const currentTask = incompleteTasks[state.currentTaskIndex];
      if (!currentTask) {
        return '<div class="min-h-screen bg-gray-900 flex items-center justify-center p-4">' +
          '<div class="bg-gray-800 rounded-3xl shadow-2xl p-12 max-w-md w-full text-center">' +
            '<p class="text-gray-400 mb-8">No tasks available. Add some tasks to get started!</p>' +
            '<button onclick="state.showManageTasks = true; render()" class="bg-indigo-600 text-white px-6 py-3 rounded-full font-semibold transition-colors w-full">' +
              'Manage Tasks' +
            '</button>' +
          '</div>' +
        '</div>';
      }

      const progress = Math.min((currentTask.completed / currentTask.allocated) * 100, 100);
      const taskNum = incompleteTasks.findIndex(function(t) { return t.id === currentTask.id; }) + 1;

      return '<div class="min-h-screen bg-gray-900 flex flex-col">' +
        '<div class="flex-1 flex items-center justify-center p-4">' +
          '<div class="bg-gray-800 rounded-3xl shadow-2xl p-8 max-w-md w-full">' +
            '<div class="text-center mb-8">' +
              '<div class="inline-block bg-indigo-900 text-indigo-300 px-4 py-1 rounded-full text-sm font-medium mb-4">' +
                'Task ' + taskNum + ' of ' + incompleteTasks.length +
              '</div>' +
              '<h1 class="text-4xl font-bold text-white mb-2">' + escapeHtml(currentTask.name) + '</h1>' +
              '<div class="text-gray-400 text-lg">' +
                formatTime(currentTask.completed) + ' / ' + formatTime(currentTask.allocated) +
              '</div>' +
            '</div>' +
            '<div class="mb-8">' +
              '<div class="bg-gray-700 rounded-full h-4 overflow-hidden">' +
                '<div class="bg-gradient-to-r h-full transition-all" style="width: ' + progress + '%; transition-duration: 1000ms;"></div>' +
              '</div>' +
            '</div>' +
            '<div class="flex gap-3 mb-6">' +
              '<button onclick="toggleTimer()" class="flex-1 flex items-center justify-center gap-2 py-4 rounded-2xl font-semibold text-lg transition-all ' +
                (state.isTimerRunning ? 'bg-red-600' : 'bg-indigo-600') + ' text-white">' +
                (state.isTimerRunning ? 
                  '<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg> Pause' :
                  '<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg> Start'
                ) +
              '</button>' +
              (incompleteTasks.length > 1 ? 
                '<button onclick="nextTask()" class="px-6 py-4 bg-gray-700 rounded-2xl transition-colors text-white">' +
                  '<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                    '<polygon points="5 4 15 12 5 20 5 4"></polygon>' +
                    '<line x1="19" y1="5" x2="19" y2="19"></line>' +
                  '</svg>' +
                '</button>' : ''
              ) +
            '</div>' +
            (incompleteTasks.length > 1 ? 
              '<div class="flex gap-2 justify-center mb-6">' +
                incompleteTasks.map(function(task, idx) {
                  return '<button onclick="selectTask(' + idx + ')" class="h-2 rounded-full transition-all ' +
                    (idx === state.currentTaskIndex ? 'bg-indigo-500 w-8' : 'bg-gray-600 w-2') +
                    '"></button>';
                }).join('') +
              '</div>' : ''
            ) +
            '<button onclick="state.showManageTasks = true; render()" class="w-full flex items-center justify-center gap-2 bg-gray-700 text-white py-3 rounded-2xl transition-colors font-medium">' +
              '<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                '<line x1="8" y1="6" x2="21" y2="6"></line>' +
                '<line x1="8" y1="12" x2="21" y2="12"></line>' +
                '<line x1="8" y1="18" x2="21" y2="18"></line>' +
                '<line x1="3" y1="6" x2="3.01" y2="6"></line>' +
                '<line x1="3" y1="12" x2="3.01" y2="12"></line>' +
                '<line x1="3" y1="18" x2="3.01" y2="18"></line>' +
              '</svg>' +
              'Manage Tasks' +
            '</button>' +
          '</div>' +
        '</div>' +
      '</div>';
    }

    function renderManageView() {
      return '<div class="min-h-screen bg-gray-900 p-4 no-scrollbar" style="overflow-y: auto;">' +
        '<div class="max-w-md mx-auto">' +
          '<div class="flex items-center gap-3 mb-6">' +
            '<button onclick="state.showManageTasks = false; render()" class="p-2 bg-gray-800 rounded-lg text-white transition-colors">' +
              '<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                '<line x1="19" y1="12" x2="5" y2="12"></line>' +
                '<polyline points="12 19 5 12 12 5"></polyline>' +
              '</svg>' +
            '</button>' +
            '<h2 class="text-2xl font-bold text-white flex-1">Manage Tasks</h2>' +
            '<button onclick="exportTasks()" class="p-2 bg-gray-700 rounded-lg text-white transition-colors" title="Export">' +
              '<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>' +
                '<polyline points="7 10 12 15 17 10"></polyline>' +
                '<line x1="12" y1="15" x2="12" y2="3"></line>' +
              '</svg>' +
            '</button>' +
            '<button onclick="importTasks()" class="p-2 bg-gray-700 rounded-lg text-white transition-colors" title="Import">' +
              '<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>' +
                '<polyline points="17 8 12 3 7 8"></polyline>' +
                '<line x1="12" y1="3" x2="12" y2="15"></line>' +
              '</svg>' +
            '</button>' +
            '<button onclick="showAddForm()" class="p-2 bg-indigo-600 rounded-lg text-white transition-colors">' +
              '<svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                '<line x1="12" y1="5" x2="12" y2="19"></line>' +
                '<line x1="5" y1="12" x2="19" y2="12"></line>' +
              '</svg>' +
            '</button>' +
          '</div>' +
          '<div id="add-form-container"></div>' +
          '<div class="space-y-3" id="tasks-list">' +
            state.tasks.map(function(task, index) {
              if (!task) return '';
              const progress = Math.min((task.completed / task.allocated) * 100, 100);
              const isComplete = task.completed >= task.allocated;
              return '<div class="bg-gray-800 rounded-2xl p-4" data-task-id="' + task.id + '">' +
                '<div class="flex items-center gap-3">' +
                  '<div class="text-gray-500 cursor-move" style="touch-action: none;">' +
                    '<svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                      '<circle cx="9" cy="5" r="1"></circle>' +
                      '<circle cx="9" cy="12" r="1"></circle>' +
                      '<circle cx="9" cy="19" r="1"></circle>' +
                      '<circle cx="15" cy="5" r="1"></circle>' +
                      '<circle cx="15" cy="12" r="1"></circle>' +
                      '<circle cx="15" cy="19" r="1"></circle>' +
                    '</svg>' +
                  '</div>' +
                  '<div class="flex-1 cursor-pointer" onclick="showEditForm(' + task.id + ', \'' + escapeHtml(task.name).replace(/'/g, "\\'") + '\', ' + task.allocated + ')">' +
                    '<div class="text-white font-medium mb-1">' + escapeHtml(task.name) + '</div>' +
                    '<div class="text-sm text-gray-400">' +
                      formatTime(task.completed) + ' / ' + formatTime(task.allocated) +
                    '</div>' +
                    '<div class="bg-gray-700 rounded-full h-1.5 mt-2 overflow-hidden">' +
                      '<div class="bg-indigo-500 h-full transition-all" style="width: ' + progress + '%"></div>' +
                    '</div>' +
                  '</div>' +
                  '<div class="flex flex-col gap-1">' +
                    (!isComplete ? 
                      '<button onclick="completeTask(' + task.id + ')" class="p-1.5 bg-green-600 rounded-lg text-white transition-colors" title="Mark Complete">' +
                        '<svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                          '<polyline points="20 6 9 17 4 12"></polyline>' +
                        '</svg>' +
                      '</button>' : ''
                    ) +
                    (task.completed > 0 ? 
                      '<button onclick="resetTask(' + task.id + ')" class="p-1.5 bg-yellow-600 rounded-lg text-white transition-colors" title="Reset Progress">' +
                        '<svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                          '<polyline points="23 4 23 10 17 10"></polyline>' +
                          '<path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>' +
                        '</svg>' +
                      '</button>' : ''
                    ) +
                    '<button onclick="deleteTask(' + task.id + ')" class="p-1.5 bg-red-600 rounded-lg text-white transition-colors" title="Delete">' +
                      '<svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
                        '<polyline points="3 6 5 6 21 6"></polyline>' +
                        '<path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>' +
                      '</svg>' +
                    '</button>' +
                  '</div>' +
                '</div>' +
              '</div>';
            }).join('') +
          '</div>' +
        '</div>' +
      '</div>';
    }

    function escapeHtml(text) {
      var map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
      };
      return String(text).replace(/[&<>"']/g, function(m) { return map[m]; });
    }

    function showAddForm() {
      var container = document.getElementById('add-form-container');
      if (!container) return;
      
      container.innerHTML = 
        '<div class="bg-gray-800 rounded-2xl p-4 mb-4">' +
          '<input type="text" id="new-task-name" placeholder="Task name" class="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white mb-2" style="color: white;">' +
          '<div class="flex gap-2 mb-2">' +
            '<button onclick="setQuickTime(15)" class="flex-1 px-3 py-2 bg-gray-700 text-white rounded-lg transition-colors text-sm">15m</button>' +
            '<button onclick="setQuickTime(30)" class="flex-1 px-3 py-2 bg-gray-700 text-white rounded-lg transition-colors text-sm">30m</button>' +
            '<button onclick="setQuickTime(60)" class="flex-1 px-3 py-2 bg-gray-700 text-white rounded-lg transition-colors text-sm">1h</button>' +
            '<button onclick="setQuickTime(90)" class="flex-1 px-3 py-2 bg-gray-700 text-white rounded-lg transition-colors text-sm">1.5h</button>' +
          '</div>' +
          '<div class="flex gap-2">' +
            '<input type="number" step="0.5" id="new-task-time" placeholder="Minutes (or use buttons above)" class="flex-1 px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white" style="color: white;">' +
            '<button onclick="submitAddForm()" class="px-6 bg-indigo-600 text-white rounded-lg transition-colors font-medium">Add</button>' +
            '<button onclick="cancelAddForm()" class="px-4 bg-gray-700 text-white rounded-lg transition-colors">âœ•</button>' +
          '</div>' +
        '</div>';
      
      var input = document.getElementById('new-task-name');
      if (input) input.focus();
    }

    function setQuickTime(minutes) {
      var input = document.getElementById('new-task-time');
      if (input) input.value = minutes;
    }

    function submitAddForm() {
      var nameInput = document.getElementById('new-task-name');
      var timeInput = document.getElementById('new-task-time');
      if (!nameInput || !timeInput) return;
      
      var name = nameInput.value;
      var time = timeInput.value;
      if (addTask(name, time)) {
        cancelAddForm();
      }
    }

    function cancelAddForm() {
      var container = document.getElementById('add-form-container');
      if (container) container.innerHTML = '';
    }

    function showEditForm(id, name, allocated) {
      var taskEl = document.querySelector('[data-task-id="' + id + '"]');
      if (!taskEl) return;
      
      taskEl.innerHTML = 
        '<div>' +
          '<input type="text" id="edit-name-' + id + '" value="' + name + '" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white mb-2" style="color: white;">' +
          '<div class="flex gap-2">' +
            '<input type="number" step="0.5" id="edit-time-' + id + '" value="' + allocated + '" class="flex-1 px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white" style="color: white;">' +
            '<button onclick="submitEdit(' + id + ')" class="px-4 bg-indigo-600 text-white rounded-lg transition-colors text-sm">Save</button>' +
            '<button onclick="render()" class="px-4 bg-gray-700 text-white rounded-lg transition-colors text-sm">Cancel</button>' +
          '</div>' +
        '</div>';
      
      var input = document.getElementById('edit-name-' + id);
      if (input) input.focus();
    }

    function submitEdit(id) {
      var nameInput = document.getElementById('edit-name-' + id);
      var timeInput = document.getElementById('edit-time-' + id);
      if (!nameInput || !timeInput) return;
      
      var name = nameInput.value;
      var time = timeInput.value;
      updateTask(id, name, time);
    }

    function render() {
      if (state.isRendering) return;
      state.isRendering = true;
      
      try {
        var app = document.getElementById('app');
        if (!app) return;
        
        if (state.showManageTasks) {
          app.innerHTML = renderManageView();
          setupDragAndDrop();
        } else {
          app.innerHTML = renderTimerView();
        }
      } finally {
        state.isRendering = false;
      }
    }

    function setupDragAndDrop() {
      var tasksList = document.getElementById('tasks-list');
      if (!tasksList) return;

      var draggedElement = null;
      var draggedIndex = null;
      var touchStartY = 0;
      var touchCurrentY = 0;
      var isDragging = false;

      var tasks = tasksList.querySelectorAll('[data-task-id]');
      tasks.forEach(function(el, index) {
        el.setAttribute('draggable', 'true');
        
        el.addEventListener('dragstart', function(e) {
          draggedElement = el;
          draggedIndex = index;
          el.style.opacity = '0.5';
        });

        el.addEventListener('dragend', function(e) {
          el.style.opacity = '1';
          var allTasks = tasksList.querySelectorAll('[data-task-id]');
          allTasks.forEach(function(item) {
            item.style.borderTop = '';
            item.style.borderBottom = '';
          });
        });

        el.addEventListener('dragover', function(e) {
          e.preventDefault();
          if (draggedElement !== el) {
            var bounding = el.getBoundingClientRect();
            var offset = bounding.y + (bounding.height / 2);
            if (e.clientY - offset > 0) {
              el.style.borderBottom = '2px solid #6366f1';
              el.style.borderTop = '';
            } else {
              el.style.borderTop = '2px solid #6366f1';
              el.style.borderBottom = '';
            }
          }
        });

        el.addEventListener('drop', function(e) {
          e.preventDefault();
          if (draggedElement !== el) {
            var dropIndex = index;
            moveTask(draggedIndex, dropIndex);
          }
        });

        var gripIcon = el.querySelector('.cursor-move');
        if (gripIcon) {
          gripIcon.addEventListener('touchstart', function(e) {
            e.preventDefault();
            draggedElement = el;
            draggedIndex = index;
            touchStartY = e.touches[0].clientY;
            isDragging = true;
            el.style.opacity = '0.7';
            el.style.transform = 'scale(1.05)';
          }, { passive: false });

          gripIcon.addEventListener('touchmove', function(e) {
            if (!isDragging) return;
            e.preventDefault();
            touchCurrentY = e.touches[0].clientY;
            var deltaY = touchCurrentY - touchStartY;
            
            el.style.transform = 'translateY(' + deltaY + 'px) scale(1.05)';
            
            var elements = Array.from(tasksList.querySelectorAll('[data-task-id]'));
            elements.forEach(function(item, idx) {
              if (item === el) return;
              var rect = item.getBoundingClientRect();
              if (touchCurrentY > rect.top && touchCurrentY < rect.bottom) {
                item.style.borderTop = idx < draggedIndex ? '2px solid #6366f1' : '';
                item.style.borderBottom = idx > draggedIndex ? '2px solid #6366f1' : '';
              } else {
                item.style.borderTop = '';
                item.style.borderBottom = '';
              }
            });
          }, { passive: false });

          gripIcon.addEventListener('touchend', function(e) {
            if (!isDragging) return;
            e.preventDefault();
            isDragging = false;
            
            var elements = Array.from(tasksList.querySelectorAll('[data-task-id]'));
            var dropIndex = draggedIndex;
            
            elements.forEach(function(item, idx) {
              var rect = item.getBoundingClientRect();
              if (touchCurrentY > rect.top && touchCurrentY < rect.bottom && idx !== draggedIndex) {
                dropIndex = idx;
              }
              item.style.borderTop = '';
              item.style.borderBottom = '';
            });
            
            el.style.opacity = '1';
            el.style.transform = '';
            
            if (dropIndex !== draggedIndex) {
              moveTask(draggedIndex, dropIndex);
            }
            
            draggedElement = null;
          }, { passive: false });
        }
      });
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
      stopTimer();
    });

    // Check timer when page becomes visible
    document.addEventListener('visibilitychange', function() {
      if (!document.hidden) {
        checkTimerOnLoad();
        if (state.isTimerRunning) {
          startTimer();
        }
        render();
      } else {
        if (state.timerInterval && state.isTimerRunning) {
          clearInterval(state.timerInterval);
          state.timerInterval = null;
        }
      }
    });

    // Request notification permission on first interaction
    var hasRequestedPermission = false;
    document.addEventListener('click', function() {
      if (!hasRequestedPermission) {
        hasRequestedPermission = true;
        requestNotificationPermission();
      }
    }, { once: true });

    // Initialize app
    (function init() {
      try {
        initializeState();
        checkTimerOnLoad();
        if (state.isTimerRunning) {
          startTimer();
        }
        render();
      } catch (e) {
        console.error('Initialization error:', e);
        document.getElementById('app').innerHTML = 
          '<div class="min-h-screen bg-gray-900 flex items-center justify-center p-4">' +
            '<div class="bg-gray-800 rounded-2xl p-8 text-center">' +
              '<p class="text-white mb-4">Failed to initialize app</p>' +
              '<button onclick="location.reload()" class="bg-indigo-600 text-white px-6 py-3 rounded-lg">Reload</button>' +
            '</div>' +
          '</div>';
      }
    })();
  </script>
</body>
</html>
